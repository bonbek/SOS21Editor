<?xml version="1.0" encoding="UTF-8"?>
<mx:Box xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:flmp="flexmapeditor.view.components.*"
	width="100%" height="100%"
	paddingTop="10"
	addedToStage="onAdd();"
	removedFromStage="onClose();"
	creationComplete="onCreationComplete(event);">
	
	<mx:Script>
	    <![CDATA[
		
		import flash.events.Event;
		import flash.events.MouseEvent;
		import flash.net.Responder;
		import flash.display.DisplayObject;
		import flash.filters.GlowFilter;
		import flash.utils.Dictionary;
		import flash.geom.Point;
		
		import mx.events.CloseEvent;
		import mx.events.FlexEvent;
		import mx.events.ListEvent;
		import mx.events.DragEvent;
		import mx.managers.PopUpManager;
		import mx.collections.ArrayCollection;
		import mx.core.IFlexDisplayObject;
		import mx.core.UIComponent;
		import mx.events.ItemClickEvent;
		
		import mx.controls.ComboBox;
		import mx.controls.Text;
		import mx.controls.TextArea;
		
		/**
		*	Module édition des triggers
		*
		*	@langversion ActionScript 3.0
		*	@playerversion Flash 9.0
		*
		*/

		//---------------------------------------
		// PUBLIC VARIABLES
		//---------------------------------------

		public var isoscene:Object;
		public var dataMapProxy:Object;
		public var collisionGridProxy:Object;
		public var triggersProxy:Object;
		public var beta:Object;
		public var mapList:Array;
		
//		public var triggersVisualizer:TriggersVisualizer;
			
		// assets boutons éditer / ajouter / supprimer
		[Embed("icons/cog_add.png")]
		public var cog_addIcon:Class;
		[Embed("icons/cog_delete.png")]
		public var cog_deleteIcon:Class;
		[Embed("icons/cog_edit.png")]
		public var cog_editIcon:Class;
		[Embed("icons/cog_back.png")]
		public var cog_backIcon:Class;
		
		// dp liste des triggers qui sont modifiés par un trigger
		/*[Bindable]
		public var dpOverrideTriggers:ArrayCollection = new ArrayCollection([]);*/

		// dp boutons éditer / ajouter / supprimer les triggers chainés (au trigger en cours de sélection)
		[Bindable]
		public var dpBtnEAR:Array = [	{ icon:cog_editIcon, toolTip:"éditer l'action sélectionnée", id:"compEdTrigger" },
										{ icon:cog_addIcon, toolTip:"ajouter une action", id:"compAddTrigger" },
										{ icon:cog_deleteIcon, toolTip:"supprimer l'action sélectionnée", id:"compRemTrigger"} ];

		// dp boutons éditer / ajouter / supprimer les triggers chainés (au trigger en cours de sélection)
		[Bindable]
		public var dpBtnEARAllTList:Array = [	{ icon:cog_editIcon, toolTip:"éditer l'action sélectionnée", id:"allEdTrigger" },
										{ icon:cog_addIcon, toolTip:"ajouter une action", id:"allAddTrigger" },
										{ icon:cog_deleteIcon, toolTip:"supprimer l'action sélectionnée", id:"allRemTrigger"} ];
							
		// dp boutons ajouter / supprimer des triggers (liste des triggers de l'objet selectionné)
		[Bindable]
		public var dpBtnARB:Array = [	{ icon:cog_addIcon, toolTip:"ajouter une action", id:"addTrigger" },
										{ icon:cog_deleteIcon, toolTip:"supprimer l'action sélectionnée", id:"remTrigger" },
										{ icon:cog_backIcon, toolTip:"retourner à l'action parente", id:"backToParent" } ];
		
		// dp List des triggers chainés au trigger en cours d'édition
		[Bindable]
		public var dtChainedTriggers:ArrayCollection = new ArrayCollection([]);
		
		[Bindable]
		public var dtTargetTriggers:ArrayCollection = new ArrayCollection([]);
		
		// dp liste des actions (triggers)
		[Bindable]
		public var dtTriggerTypes:ArrayCollection = new ArrayCollection([
										{label:"", data:0},
										{label:"bonus joueur", data:103},
										{label:"changer de scene", data:1},
										{label:"déplacer un tile", data:6},
										{label:"étiquette", data:7},
										{label:"lancer un/des quiz", data:3},
										{label:"lecteur Viméo", data:8, enabled:false},
										{label:"lien/mailto/fichier", data:2},
										{label:"menu contextuel", data:4},
										{label:"popup html", data:9},
										{label:"signal ressources", data:5, enabled:false},
										{label:"::dispatch event::", data:10, enabled:false}]);
										

		// dp pour le combo type de déclenchement
		[Bindable]
		public var dtTriggerFireTypes:ArrayCollection;
		
		// dp liste de tous les triggers
		[Bindable]
		public var dpAllTriggers:ArrayCollection = new ArrayCollection([]);
		
		public var dtTriggerFireTypesForCells:ArrayCollection = new ArrayCollection([
										{label:"", data:0},
										{label:"roll over", data:0, enabled:false},
										{label:"roll out", data:1, enabled:false},
										{label:"click", data:2, enabled:false},
										{label:"click enfoncé", data:5, enabled:false},
										{label:"click relaché", data:6, enabled:false},																			
										{label:"entrée céllule", data:4, enabled:true},
										{label:"sortie céllule", data:3, enabled:true},
										{label:"en début de scène", data:8, enabled:false},
										{label:"chaîné à une action", data:-1, enabled:false}]);
										
		public var dtTriggerFireTypesForTiles:ArrayCollection = new ArrayCollection([
										{label:"", data:0},
										{label:"roll over", data:0, enabled:true},
										{label:"roll out", data:1, enabled:true},
										{label:"click", data:2, enabled:true},
										{label:"click enfoncé", data:5, enabled:true},
										{label:"click relaché", data:6, enabled:true},																			
										{label:"entrée céllule", data:4, enabled:false},
										{label:"sortie céllule", data:3, enabled:false},
										{label:"en début de scène", data:8, enabled:true},
										{label:"chaîné à une action", data:-1, enabled:false}]);
										
		public var dtTriggerFireTypesForChain:ArrayCollection = new ArrayCollection([
										{label:"", data:0, enabled:false},
										{label:"roll over", data:0, enabled:false},
										{label:"roll out", data:1, enabled:false},
										{label:"click", data:2, enabled:false},
										{label:"click enfoncé", data:5, enabled:false},
										{label:"click relaché", data:6, enabled:false},																			
										{label:"entrée céllule", data:4, enabled:false},
										{label:"sortie céllule", data:3, enabled:false},
										{label:"en début de scène", data:8, enabled:true},
										{label:"chaîné à une action", data:-1, enabled:true}]);
		

		/*<mx:DataGridColumn dataField="id" headerText="id" />
           <mx:DataGridColumn dataField="title" headerText="action" />
           <mx:DataGridColumn dataField="source" headerText="source" />
		<mx:DataGridColumn dataField="chained" headerText="chainage" />*/

		/*public function buildTriggerList():void
		{
			dpAllTriggers.removeAll()
			var all:Array = triggersProxy.allTriggers;
			var tr:Object;
			var n:int = all.length;
			for (var i:int = 0; i < n; i++) {
				tr = all[i];
				dpAllTriggers.addItem({ id:tr.id, title:triggersClass[tr.triggerClassId], source:getSourceDescription(tr), trigger:tr })
			}
		}*/
		
		public function updateTriggersList () : void
		{
			dpAllTriggers.removeAll()
			var all:Array = triggersProxy.allTriggers;
			var tr:Object;
			var schained:String;
			var schainedTo:String;
			var n:int = all.length;
			for (var i:int = 0; i < n; i++) {
				tr = all[i];
				schained = tr.hasChainedTrigger ? tr.arguments["onComplete"].join(",") : "";				
				schainedTo = tr.isChained ? tr.chainedTo.join(",") : "";
				dpAllTriggers.addItem({ id:tr.id, title:triggersClass[tr.triggerClassId],
										source:getSourceDescription(tr), firetype:tr.fireEventType,
										chained:schained, chainedTo:schainedTo, data:tr });
			}
		}
		
		public function refreshTriggerList(toRefresh:Array = null):void
		{
			if (!toRefresh) toRefresh = triggersProxy.allTriggers;
			
			var trprop:Object;
			var itList:Object;
			
			var n:int = toRefresh.length;
			var n2:int = dpAllTriggers.length;
			
			while(--n > -1)
			{
				trprop = toRefresh[n];
				while (--n2 > -1)
				{
					itList = dpAllTriggers.getItemAt(n2);
					if (itList.data == trprop)
					{
						with (itList)
						{
							id:trprop.id;
							title = triggersClass[trprop.triggerClassId];
							source = getSourceDescription(trprop);
							firetype = trprop.fireEventType;
							chained = trprop.hasChainedTrigger ? trprop.arguments["onComplete"].join(",") : "";
							chainedTo = trprop.isChained ? trprop.chainedTo.join(",") : "";
						}
						dpAllTriggers.itemUpdated(itList);
						break;
					}
				}
			}
		}
		
		public function get triggersClass():Array {
			return _triggersClass;
		}
		
		//---------------------------------------
		// PRIVATE VARIABLES
		//---------------------------------------
		
		// formulaire additionnel des triggers
		private var currentAddForm:Object;
		// objet cible du / des triggers en cours d'édition
		private var currentTarget:Object;
		// liste des id classe de triggers
		public var _triggersClass:Array = [];
		// liste des formulaire additionnels
		private var addForms:Array = [];
		
		private var cellTemplate:Object;
		private var cellTriggerVisible:Boolean = false;
		private var editFromNotFromMPopup:PopupList;
		
		//---------------------------------------
		// GETTER / SETTERS
		//---------------------------------------
		
		/*public function get currentTrigger () : Object
		{
			return cliTargetTriggers.selectedItem ? cliTargetTriggers.selectedItem.data : null;
		}*/
		
		[Bindable]
		public var currentTrigger:Object;
		
		//---------------------------------------
		// PUBLIC METHODS
		//---------------------------------------
		
		/**
		 *	Affiche les triggers sur grille
		 * 
		 */ 
		public function showGridTriggers():void
		{
			var alTriggers:Array = triggersProxy.allTriggers;
			var n:int = alTriggers.length;
			while (--n > -1)
			{
				var tr:Object = alTriggers[n];
				var cell:Array = tr.refId.split("-");
				if (cell.length == 3)
				{
					var tv:Object = beta.createTileView(createCCell());
					var up:Object = beta.createUPoint(cell[0], cell[1], cell[2], dataMapProxy.tilew, dataMapProxy.tileh, dataMapProxy.tiled);
					var t:Object = beta.createAbstractTile(tr.refId, up, tv);
					isoscene.debugLayer.addTile(t);
				}
			}
			cellTriggerVisible = true;
		}
		
		/**
		 *	Cache les triggers sur grille
		 * 
		 */
		public function hideGridTriggers():void
		{
			isoscene.debugLayer.removeAllTile();
			cellTriggerVisible = false;
		}
		
		/**
		 * Lance la crétion de triggers sur grille	
		 *  
		 */
		public function createCellsTrigger():void
		{
			parentApplication.viewport.removeEventListener(MouseEvent.CLICK, sceneMouseHandler, false);
			cellTemplate = addCellTrigger(0, 0, 0);
			stage.addEventListener(MouseEvent.MOUSE_MOVE, createCellsTriggerHandler, false, 0, true);
			stage.addEventListener(MouseEvent.CLICK, createCellsTriggerHandler, false, 0, true);
		}
		
		/**
		 * Stop la création de triggers sur grille	
		 *  
		 */		
		public function stopCreateCellsTrigger():void
		{
			stage.removeEventListener(MouseEvent.MOUSE_MOVE, createCellsTriggerHandler, false);
			stage.removeEventListener(MouseEvent.CLICK, createCellsTriggerHandler, false);
			isoscene.debugLayer.removeTile(cellTemplate);
			cellTemplate = null;
			parentApplication.viewport.addEventListener(MouseEvent.CLICK, sceneMouseHandler, false, 0, true);
		}
		
		/**
		 *	Retourne un sprite forme losange
		 *	@return Sprite
		 */
		public function createCCell(col:uint = 0xFF9900):Sprite
		{
			var sp:Sprite = new Sprite();
			
			sp.graphics.beginFill(col, 0.3);
			sp.graphics.lineStyle(1, 0x777777);

			sp.graphics.lineTo(dataMapProxy.tilew / 2, dataMapProxy.tileh / 2);
			sp.graphics.lineTo(0, dataMapProxy.tileh);
			sp.graphics.lineTo(-(dataMapProxy.tilew / 2), dataMapProxy.tileh / 2);
			sp.graphics.lineTo(0, 0);
			
			return sp;
		}

		/**
		 *	Crée un nouveau trigger
		 * 	Mets à jour l'affichage
		 *	@return Object	de type TriggerProperties
		 */
		public function createTrigger(iclassId:int = 0, stileRefId:String = null, ifireType:int = -1, oarguments:Object = null):Object
		{
			// prochain identifiant valide pour nouveau un trigger
			var trid:int = findNextAvailableTriggerId();	
									
			// creation du TriggerProperties
			var dt:Object =	{	id:trid, classId:iclassId, tileRefId:stileRefId,
								fireType:ifireType, arguments:oarguments ? oarguments : {}	};
			// ajout du trigger au proxy
			var trprop:Object = triggersProxy.createTrigger(dt);
			
			// mise à jour de l'affichage
			
			// > liste de tous les triggers
			var itDg:Object = { id:trprop.id, title:triggersClass[trprop.triggerClassId], source:getSourceDescription(trprop), data:trprop };
			dpAllTriggers.addItem(itDg);
			var itDgInd:int = dpAllTriggers.getItemIndex(itDg);
			dgAllTriggersList.selectedIndex = itDgInd;
			dgAllTriggersList.scrollToIndex(itDgInd);
			if (currentTarget)
			{
				// > si target en cours d'édition et que le nouveau trigger est
				// associé à celle-ci on mets à jour le formulaire avec sélection auto
				if (currentTarget.ID == stileRefId)
				{
					updateForm(trprop, true, true);
				}
			}			
			
			return trprop;
		}
		
		/**
		 * Supprime tous les triggers d'une source
		 *	@param t Object
		 */
		public function removeTargetTriggers (tid:String) : void
		{
		//	if (triggersProxy.hasTrigger(t)) {
				var tlist:Array = triggersProxy.getAllTriggers(tid);
				var toRemList:Array = [];
				var trprop:Object;
				var n:int = tlist.length;
				while (--n > -1)
				{
					trprop = tlist[n];
					if (!trprop.isChained) {
						toRemList.push(trprop);
					}
				}
				// suppression dans la liste tous le triggers
				n = toRemList.length;
				var n2:int = dpAllTriggers.length;
				while (--n > -1)
				{
					trprop = toRemList[n];
					if (currentState == "onAdd")
					{
						while (--n2 > -1)
						{
							if (dpAllTriggers.getItemAt(n2).data == trprop)
							{
								dpAllTriggers.removeItemAt(n2);
								break;
							}
						}
					}
					addForms[trprop.triggerClassId].onDeleteTrigger(trprop);
					triggersProxy.removeTrigger(trprop.id);
				}
//			}
		}
		
		/**
		 * Retourne le prochain identifiant de trigger valide
		 * 
		 *	@return int
		 */
		public function findNextAvailableTriggerId():int
		{
			var li:Array = triggersProxy.allTriggers;
			var n:int = li.length;
			var i:int = 0;
			while (--n > -1 )
				if (li[n].id > i) i = li[n].id;

			return i + 1;
		}
		
		/**
		 * 	Retourne la desciption du sourceTarget d'un trigger;
		 *	@param trigger Object
		 *	@return String
		 */
		public function getSourceDescription(trigger:Object):String
		{
			var refId:String = trigger.refId;
			var stype:String;
			if (trigger.refId != "null" && trigger.refId)
			{
				if (refId.split("-").length == 3) {
					stype = "céllule (" + refId + ")";
				} else {
					var refObj:Object = parentApplication.isosceneHelper.getTile(refId);
					stype = refObj.name + " (id:" + refId + ")";
				}
			} else {
				stype = "aucune";
			}
						
			return stype;
		}
		
		/**
		 * Lance la sauvegarde
		 * 
		 */
		public function save():void
		{
			if (currentAddForm)
				currentAddForm.updateOnSave();

			var alTriggers:Array = triggersProxy.allTriggers;
			var n:int = alTriggers.length;
			alTriggers.sortOn("id", Array.DESCENDING);
			var pa:Array = [];
			var t:Object;
			var nt:Object;
			var args:Dictionary;
			while (--n > -1)
			{
				t = alTriggers[n];
				// on clean le trigger
				cleanTriggerV2(t);
				
				nt = {	id:t.id, classId:t.triggerClassId, tileRefId:t.refId,
						fireType:t.fireType	};
				
				if (t.inactiveFromMaps)
					nt.notFM = t.inactiveFromMaps;

				if (t.activeFromMaps)
					nt.fromM = t.activeFromMaps;
					
				args = t.arguments;
				nt.arguments = {};
				for (var p:String in args)
					nt.arguments[p] = args[p];
				
				// param slid, lien symbolique
				var slid:int = t.symbLinkId;
				if (slid > -1)
					nt.arguments["slid"] = slid;
				// param nombre execution du trigger
				var fc:int = t.maxFireCount;
				if (fc < int.MAX_VALUE)
					nt.arguments["fireCount"] = fc;

				pa.push(nt);
			}
			
			parentApplication.gateway.call("sos21Services.updateDataMap", new Responder(onSaveResult, onFault), dataMapProxy.getData().id, "triggers", pa);
		}
		
		//---------------------------------------
		// EVENT HANDLERS
		//---------------------------------------
		
		/**
		 * Reception cliques dans la toolbar
		 * 
		 *	@param event MouseEvent
		 */
		private function triggerEditorToolBarHandler(event:MouseEvent):void
		{
			switch (event.target)
			{
				case parentApplication.triggerEditorToolBar.btnAddCellTrigger :
				{
					if (parentApplication.triggerEditorToolBar.btnAddCellTrigger.selected)
					{
						createCellsTrigger();
						if (!cellTriggerVisible) {
							showGridTriggers();
							parentApplication.triggerEditorToolBar.btnShowHideCellTrigger.selected = true;
						}
					} else {
						stopCreateCellsTrigger();
					}
					break;
				}
				case parentApplication.triggerEditorToolBar.btnShowHideCellTrigger :
				{
					if (!cellTemplate)
					{
						if (cellTriggerVisible)
							hideGridTriggers();
						else
							showGridTriggers();
					} else {
						parentApplication.triggerEditorToolBar.btnShowHideCellTrigger.selected = true;
					}
					break;
				}
			}
		}
		
		/**
		 *	Reception events sur la scene pendant le mode
		 *  création de triggers sur grille
		 * 
		 *	@param event Event
		 */
		private function createCellsTriggerHandler(event:Event):void
		{
			event.preventDefault();
			
			var p:Point = isoscene.debugLayer.findGridPoint(new Point (stage.mouseX, stage.mouseY));
			var up:Object = beta.createUPoint(p.x, p.y, 0);
			var t:Object = parentApplication.isosceneHelper.getTile(up.xu + "-" + up.yu + "-" + up.zu);
			
			switch (event.type)
			{
				case MouseEvent.MOUSE_MOVE :
				{
					cellTemplate.umove(up);
					break;
				}
				case MouseEvent.CLICK :
				{
					// une cellule est deja là
					if (t)
					{
						// cleanner les triggers !!!!
						/*if (triggersProxy.hasTrigger(t)) {
												var tlist:Array = triggersProxy.getAllTriggers(t.ID);
												var toRemList:Array = [];
												var trprop:Object;
												var n:int = tlist.length;
												while (--n > -1)
												{
													trprop = tlist[n];
													if (!trprop.isChained) {
														toRemList.push(trprop);
													}
												}
												// suppression dans la liste tous le triggers
												n = toRemList.length;
												var n2:int = dpAllTriggers.length;
												while (--n > -1)
												{
													trprop = toRemList[n];
													while (--n2 > -1)
													{
														if (dpAllTriggers.getItemAt(n2).data == trprop)
														{
															dpAllTriggers.removeItemAt(n2);
															break;
														}
													}
													addForms[trprop.triggerClassId].onDeleteTrigger(trprop);
													triggersProxy.removeTrigger(trprop.id);
												}
											}*/
						if (triggersProxy.hasTrigger(t))
							removeTargetTriggers(t.ID);
							
						isoscene.debugLayer.removeTile(t);
					} else {
						addCellTrigger(up.xu, up.yu, up.zu);
					}					
				}
			}			
		}
		
		/**
		 *  Réception events souris sur la scène
		 *  Sélection du tile ou cellule, mise à jour du formulaire
		 * 
		 *	@param event MouseEvent
		 */
		private function sceneMouseHandler(event:MouseEvent):void
		{
			if (event.isDefaultPrevented()) return;
			
			// on test si l'objet cliqué est le courant
			var tile:Object = event.target;
			
			if (tile == currentTarget) return;

			if (currentTarget)
			{
				if (triggersProxy.hasTrigger(currentTarget))
					currentTarget.filters = [new GlowFilter(0xFF9900)];
				else
					currentTarget.filters = [];
			}

			if ("ID" in tile)
			{
				
				// test Visualizer
//				triggersVisualizer.x = stage.mouseX - (triggersVisualizer.width / 2);
//				triggersVisualizer.y = stage.mouseY - (triggersVisualizer.height / 2);
				
				if (tile.inGroup) {
					tile = tile.inGroup.owner;
					if (tile == currentTarget) return;
				}
				
				updateForm(tile);
				tile.filters = [new GlowFilter()];
				currentTarget = tile;
			} else {
				clearForm();
				currentTarget = null;
			}
		}
		
		/**
		 * Reception selection d'une entré dans la liste
		 * des triggers
		 * 
		 *	@param event Event
		 */
		private function cliTargetTriggersHandler (event:Event) : void
		{
			// on recup le trigger
			var tprop:Object = event.target.selectedItem.data;
			updateForm(tprop);
		}
		
		/**
		 * Reception events liste triggers chainés
		 * 
		 *	@param event Event
		 */
		private function cliChainedTriggersHandler(event:Event):void
		{
			switch (event.type)
			{
				case DragEvent.DRAG_DROP :
				{
					if (cliTargetTriggers.selectedItem)
					{
						var cTrigger:Object = cliTargetTriggers.selectedItem.data;
						var devent:DragEvent = DragEvent(event);
						var dragItem:Object = devent.dragSource.dataForFormat("items")[0];
						if (devent.dragInitiator == cliChainedTriggers)
						{
							cTrigger.removeChainedTrigger(dragItem.data);
						}
						var ind:int = event.currentTarget.calculateDropIndex(event);
						cTrigger.addChainedTrigger(dragItem.data, ind);
					} else {
						event.preventDefault();
					}
					break;
				}
			}
		}

		/**
		 * Réception events liste des actions à modifiées par une action executée
		 * 
		 *	@param event Event
		 */
		private function cliOverrideTriggerHandler (event:Event):void
		{
			switch (event.type)
			{
				case DragEvent.DRAG_DROP :
				{
					if (cliTargetTriggers.selectedItem)
					{
						/*var cTrigger:Object = cliTargetTriggers.selectedItem.data;
						var devent:DragEvent = DragEvent(event);
						var dragItem:Object = devent.dragSource.dataForFormat("items")[0];
						if (devent.dragInitiator == cliChainedTriggers)
						{
							cTrigger.removeChainedTrigger(dragItem.data);
						}
						var ind:int = event.currentTarget.calculateDropIndex(event);
						cTrigger.addChainedTrigger(dragItem.data, ind);*/
					} else {
						event.preventDefault();
					}
					break;
				}
			}
		}
		
		/**
		 *	Réception events dans les combos type d'action et
		 *	type de déclenchement
		 * 
		 *	@param event Event
		 */
		private function ccbTriggerTypeHandler(event:Event):void
		{
			switch (event.target)
			{
				// selection dans le combo type d'action (on change de type de trigger)
				case ccbTriggerType :
				{
					if (event.target.selectedItem)
					{
						if (cliTargetTriggers.selectedItem)
						{
							// on recup la class du trigger nouveau
							var id:int = event.target.selectedItem.data;
							var tprop:Object = cliTargetTriggers.selectedItem.data;
							// on change son type (identifaint de classe)
							tprop.triggerClassId = id;
							// mise à jour de l'intitulé dans la liste des triggers
							updateForm();
							refreshTriggerList([tprop]);
						} else {
							event.target.selectedIndex = 0;
						}
					}
					break;
				}
				// selection dans combo type de déclenchement
				case ccbTriggerFireType :
				{
					// on recup le fireType nouveau
					if (cliTargetTriggers.selectedItem)
					{
						var ft:int = event.target.selectedItem.data;
						var tr:Object = cliTargetTriggers.selectedItem.data;
						tr.fireType = ft;
						updateForm();
						refreshTriggerList([tr]);
					}
						
					break;
				}
			}
		}
		
		/**
		 *	Réception des events pour les bars de boutons
		 *	éditer / ajouter / supprimer action
		 *  
		 *	@param event ItemClickEvent
		 */
		private function buttonBarsHandler(event:ItemClickEvent):void
		{
			switch(event.item.id)
			{
				case "addTrigger" : // > ajout d'un trigger
				{
					if (currentTarget)
					{
						var tid:String = currentTarget.ID;
						createTrigger(0, tid, tid.split("-").length == 3 ? 4 : 0);
					}
					break;
				}
				case "remTrigger" : // > suppression d'un trigger
				{					
					// trigger sélectionné dans la liste
					var torem:Object = cliTargetTriggers.selectedItem.data;
					if (torem)
					{
						// on previens le formulaire additionnel en cours du changement de type d'action
						if (currentAddForm)	{		
							currentAddForm.onDeleteTrigger(torem);
							clearAddForm();
						}
						
						// suppression dans la liste tous le triggers
						n = dpAllTriggers.length;
						while (--n > -1)
						{
							if (dpAllTriggers.getItemAt(n).data == torem)
							{
								dpAllTriggers.removeItemAt(n);
								break;
							}
						}
						
						// on supprime le trigger du proxy
						triggersProxy.removeTrigger(torem.id);
						
						// mise à jour de l'affichage dans la liste
						var ind:int = cliTargetTriggers.selectedIndex;
						cliTargetTriggers.dataProvider.removeItemAt(ind);
						var len:int = cliTargetTriggers.dataProvider.length;
						var tosel:Object;
						if (ind < len) {
							tosel = cliTargetTriggers.dataProvider.getItemAt(ind);
						} else if (len > 0) {
							tosel = cliTargetTriggers.dataProvider.getItemAt(ind - 1);
						}
							
						if (tosel) {
							updateForm(tosel.data, true, true);
						} else {
							ccbTriggerFireType.selectedIndex = 0;
							ccbTriggerType.selectedIndex = 0;
							cliChainedTriggers.dataProvider.removeAll();
						}
						
					}
					break;
				}
				case "backToParent" : // retour au parent du trigger en cours
				{
					var sel:Object = cliTargetTriggers.selectedItem.data;
					var selId:int = sel.id; // identifiant du trigger selectionné
					if (sel)
					{
						var allList:Array = triggersProxy.allTriggers;
						var n:int = allList.length;
						var tr:Object;
						while (--n > -1)
						{
							tr = allList[n];
							if (tr.hasChainedTrigger) {
								if (tr.chainedTriggers.indexOf(sel) > -1)
								{
									if (currentTarget)
									{
										if (currentTarget.ID == tr.refId)
											updateForm(tr, true, true);
									} else {
										updateForm(tr, true);
									}
									break;
								}
							}
						}
					}
					break;
				}
				case "compEdTrigger" : // > edition d'un trigger enchainé
				{
					if (cliChainedTriggers.selectedItem)
					{
						var tp:Object = cliChainedTriggers.selectedItem.data;
						updateForm(tp, true);
					}
					break;
				}
				case "compAddTrigger" : // clique sur bt ajout d'un trigger à l'enchainement
				{
					if (cliTargetTriggers.selectedItem)
					{
						var tprop:Object = createTrigger();
						// on l'ajoute au chainage du trigger en cours
						var curt:Object = cliTargetTriggers.selectedItem.data;
						curt.addChainedTrigger(tprop);
						
						updateForm();
					}
					break;
				}
				case "compRemTrigger" : // clique sur bt suppression du trigger de l'enchainement
				{
					// trigger sélectionné dans la liste
					torem = cliChainedTriggers.selectedItem.data;
					if (torem)
					{
						// suppression dans la liste tous le triggers
						n = dpAllTriggers.length;
						while (--n > -1)
						{
							if (dpAllTriggers.getItemAt(n).data == torem)
							{
								dpAllTriggers.removeItemAt(n);
								break;
							}
						}
						
						addForms[torem.triggerClassId].onDeleteTrigger(torem);
						// on supprime le trigger du proxy
						triggersProxy.removeTrigger(torem.id);
						
						var toupd:Object = cliTargetTriggers.selectedItem;
						if (toupd)
						{
							updateForm(toupd.data, true);
							refreshTriggerList([toupd.data]);
						}						
					}
					break;
				}
				case "allEdTrigger": // clique bt edit dans la liste de tous les triggers
				{
					if (dgAllTriggersList.selectedItem)
					{
						tp = dgAllTriggersList.selectedItem.data;
						if (tp.refId != "null") {
							updateForm(tp, true, true);
							selectTargetOfCurrentTrigger();
						} else {
							updateForm(tp, true);
						}
							
//						selectTargetOfCurrentTrigger();
					}
					break;
				}
				case "allAddTrigger" : // clique sur bt ajout d'un trigger dans la liste tous les triggers
				{
					createTrigger();
					break;
				}
				case "allRemTrigger" : // clique sur bt suppression du trigger dans la liste tous les triggers
				{
					var selIt:Object = dgAllTriggersList.selectedItem;
					if (selIt)
					{
						// trigger à supprimer
						var ttorem:Object = selIt.data;
						
						// mise à jour de l'affichage liste de tous le triggers
						dpAllTriggers.removeItemAt(dpAllTriggers.getItemIndex(selIt));
						
						// liste triggers en édition (liste target + chaînés)
						var dpttriggers:Array = cliTargetTriggers.dataProvider.toArray().concat(cliChainedTriggers.dataProvider.toArray());

						// test si le trigger à supprimer est dans cette liste
						var updForm:Boolean = false;
						n = dpttriggers.length;
						while (--n > -1)
						{
							if (dpttriggers[n].data == ttorem)
							{
								trace("TRIGGER DANS LA LISTE");
								updForm = true;
								break;
							}
								
						}
						
						// on supprime le trigger du proxy
						triggersProxy.removeTrigger(ttorem.id);
						
						if (updForm)
						{
							if (currentTarget)
							{
								updateForm(currentTarget);
							} else {
								clearForm();
							}
						}
					}
					break;
				}
			}
		}
		
		/**
		 * Changement dans les propriétées génériques du trigger
		 * en cours d'édition
		 *	@param e Event
		 */	
		/*private function onChangeCommonTriggerProp (e:Event) : void
		{
			switch (e.target)
			{
				// > changement du nombre maximum d'execution, si la valeur
				// est 0 ou plus petite, on passe le nombre d'exec max à infini
				case ti_maxFireCount :
				{
//					var v:int = ti_maxFireCount.text.length > 0 ? int(ti_maxFireCount.text) : -1;
//					currentTrigger.maxFireCount = v > 0 ? v : -1;
					currentTrigger.maxFireCount = ti_maxFireCount.text.length > 0 ? int(ti_maxFireCount.text) : -1;
					break;
				}
			}
		}*/
		
		/**
		 *	Reception clique dans popup edition trigger actif / inactif depuis maps 
		 *	@param event Event
		 */
		/*private function editFromNotFromMPopupHandler(event:Event):void
		{
			var bt:Object = event.target;
			
			if (bt == editFromNotFromMPopup.validateButton)
			{
				var sel:Array = editFromNotFromMPopup.itemList.selectedItems;
				var t:Object = currentTrigger;
				if (t)
				{
					var na:Array;
					var n:int = sel.length;
					if (n > 0)
					{
						na = [];
						while (--n > -1)
							na.push(sel[n].id);
					}
					
					if (btNotFM.selected)
						t.inactiveFromMaps = na;
					else if (btFromM.selected)
						t.activeFromMaps = na;
				}
				
				var lb:Object = btFromM.selected ? lbFromM : lbNotFM
				lb.enabled = na ? true : false;
				btNotFM.selected = false;
				btFromM.selected = false;

				PopUpManager.removePopUp(editFromNotFromMPopup);
				editFromNotFromMPopup = null;
			} else if (bt == editFromNotFromMPopup.cancelButton) {				
				btNotFM.selected = false;
				btFromM.selected = false;
				editFromNotFromMPopup = null;
			}
		}*/
		
		/**
		 *	Réception click boutons actif / inactif depuis scène(s)
		 *	@param event Event
		 */
		/*private function btnEditFromNotFromMHandler (event:Event) : void
		{
			var bt:Object = event.target;
			
			if (!currentTrigger) { 
				bt.selected = false;
				return;
			}
			
			var dBox:IFlexDisplayObject = PopUpManager.createPopUp(parentApplication.viewport, PopupList, true);
			PopUpManager.centerPopUp(dBox);
			editFromNotFromMPopup = PopupList(dBox)
			editFromNotFromMPopup.dpItemList = mapList;
			editFromNotFromMPopup.itemList.allowMultipleSelection = true;
			editFromNotFromMPopup.validateButton.label = "valider";
			editFromNotFromMPopup.addEventListener(MouseEvent.CLICK, editFromNotFromMPopupHandler, false, 0, true);
			
			// sélection dans la liste
			var tprop:Object = currentTrigger;
			var sList:Array;
			if (bt == btNotFM)
			{
				editFromNotFromMPopup.title = "Selection de(s) scène(s) depuis lesquel(s) l'action est inactive";
				sList = tprop.inactiveFromMaps;
			} else {
				editFromNotFromMPopup.title = "Selection de(s) scène(s) depuis lesquel(s) l'action est active";
				sList = tprop.activeFromMaps;
			}
			
			if (sList)
			{
				var ars:Array = [];
				var itList:Object;
				var n:int = mapList.length;
				while (--n > -1)
				{
					itList = editFromNotFromMPopup.itemList.dataProvider.getItemAt(n);
					if (sList.indexOf(itList.id) > -1) ars.push(itList);
				}
				if (ars.length > 0) editFromNotFromMPopup.itemList.selectedItems = ars;
			}
		}*/
		
		/**
		 * Réception de la liste des maps
		 * 
		 */
		private function onMaplistResult(result:Array):void
		{
			mapList = result;
		}
		
		/**
		 * Handler triggers sauvegradés
		 * 
		 *	@param result Boolean
		 */
		private function onSaveResult(result:Boolean):void
		{
			if (result)
				trace("---- triggers saved ----");
		}
		
		/**
		 *	Handler erreur à la sauvegarde 
		 * 
		 *	@param fault Object
		 */
		private function onFault(fault:Object):void
		{
			trace("! erreur de sauvegarde des actions ", fault);
			for (var p:String in fault)
				trace(p, " : ", fault[p])
		}		
		
		/**
		 * Réception event instance ajouté à la scène
		 * Mise en place des listeners sur la scène, affichage
		 * des glows sur les tiles, etc...
		 * 
		 *	@private
		 */
		private function onAdd():void
		{
			// on test si initialisé
			if (!triggersProxy) return;

			// on recup la liste des maps
			parentApplication.gateway.call( "sos21Services.getMapList", new Responder(onMaplistResult, onFault));
			
			var tlist:Array = parentApplication.viewport.tileList;
			var n:int = tlist.length;
			var t:Object;
			while (--n > -1)
			{
				t = tlist[n];
				t.mouseEnabled = true;
				t.buttonMode = true;
				if (triggersProxy.hasTrigger(t)) t.filters = [new GlowFilter(0xFF9900)];
			}
			
			// on enleve les listeners par défaut de la scene iso
			parentApplication.viewport.isosceneListenersEnabled = false;			
			// on affiche les triggers sur grille
			if (parentApplication.triggerEditorToolBar.btnShowHideCellTrigger.selected)
				showGridTriggers();
			
			// TEST CLEAN DES suppression des triggers associés avec un tile
			// qui n'existe plus
			var all:Array = triggersProxy.allTriggers;
			var tr:Object;
			n = all.length;
			for (var i:int = 0; i < n; i++) {
				tr = all[i];
				getSourceDescription(tr);
				if (getSourceDescription(tr).indexOf("tile") > -1)
				{
					if (!parentApplication.isosceneHelper.getTile(tr.refId))
						removeTargetTriggers(tr.refId);
				}
			}
			
			currentState = "onAdd";
			updateTriggersList();
			
			// on s'abonne aux clique sur la scène iso
			parentApplication.viewport.addEventListener(MouseEvent.CLICK, sceneMouseHandler, false, 0, true);
			parentApplication.triggerEditorToolBar.addEventListener(MouseEvent.CLICK, triggerEditorToolBarHandler, false, 0, true);
			
			cliChainedTriggers.addEventListener(DragEvent.DRAG_DROP, cliChainedTriggersHandler, false, 0, true);
//			cliOverrideTrigger.addEventListener(DragEvent.DRAG_DROP, cliOverrideTriggerHandler, false, 0, true);
			
			// on reviens sur le triggerEditor après une preview ?
			if (currentTarget) {
				updateForm(currentTarget);
				currentTarget.filters = [new GlowFilter()];
			}
		}
		
		/**
		 * Réception event instance supprimée de la scène
		 * Supression listeners remise à la normal des tiles, etc...
		 * 
		 *	@private
		 */
		private function onClose():void
		{
			clearForm();
			clearAddForm();
			
			if (cellTemplate) stopCreateCellsTrigger();
			hideGridTriggers();
						
			if (currentTarget) currentTarget.filters = [];
			
			var tlist:Array = parentApplication.viewport.tileList;
			var n:int = tlist.length;
			var t:Object;
			while (--n > -1)
			{
				t = tlist[n];
				if (triggersProxy.hasTrigger(t))
				{
					t.filters = [];
					t.buttonMode = true;
				} else {
					t.mouseEnabled = false;
				}
			}
			currentState = null;
			parentApplication.viewport.removeEventListener(MouseEvent.CLICK, sceneMouseHandler, false);
			cliChainedTriggers.removeEventListener(DragEvent.DRAG_DROP, cliChainedTriggersHandler, false);
		}
		
		/**
		*	Réception event instanciation
		*	
		*	@see mx.events.FlexEvent
		*/
		private function onCreationComplete(event:FlexEvent) : void
		{
			// stockage des réfs utiles
			collisionGridProxy = parentApplication.collisionGridProxy;
			isoscene = parentApplication.isosceneHelper.component;
			dataMapProxy = parentApplication.datamapProxy;
			beta = parentApplication.beta;
			triggersProxy = parentApplication.triggersProxy;
			
			// id's / intitulés des classes de triggers
			triggersClass[0] = "non définie";
			triggersClass[1] = "changer de scene";
			triggersClass[2] = "lien/mailto/fichier";
			triggersClass[3] = "quiz's";
			triggersClass[4] = "menu contextuel";
			triggersClass[5] = "signal ressources";
			triggersClass[6] = "deplacer un tile";
			triggersClass[7] = "étiquette";
			triggersClass[8] = "lecteur Viméo";
			triggersClass[9] = "popup html";
			triggersClass[10] = "::dispatch event::";
			triggersClass[103] = "bonus joueur";
			
			// instanciation des formulaires additionnels
			addForms = [];
			addForms[1] = new TriggerForm1();		// formulaire  changement de map
			addForms[2] = new TriggerForm2();		// formulaire popup
			addForms[3] = new TriggerForm3();		// formulaire quiz
			addForms[4] = new TriggerForm4();		// formulaire menu contexctuel
			addForms[5] = new TriggerForm5();		// formulaire signaler ressources
			addForms[6] = new TriggerForm6();		// formulaire bouger un tile
			addForms[7] = new TriggerForm7();		// formulaire tooltip
//			addForms[8] = new TriggerForm8();		// formulaire player viméo
			addForms[9] = new TriggerForm9();		// formulaire popup html
			addForms[10] = new TriggerForm10();		// formulaire dispatch event
//			addForms[101] = new TriggerForm101();	// formulaire mini jeu
			addForms[103] = new TriggerForm103();	// formulaire bonus joueur
			
			// ?
			cliTargetTriggers.dataProvider = [];
			
			tn_triggerOpts.selectedIndex = 1;
//			tn_triggerOpts.selectedIndex = ;
			
			//
			onAdd();
			
			// test Visualizer
//			triggersVisualizer = new TriggersVisualizer();			
//			parentApplication.ui.canvas.addChild(triggersVisualizer);
		}
		
		
		//---------------------------------------
		// PRIVATE & PROTECTED METHODS
		//---------------------------------------
		
		/**
		 *	Ajoute un tile "cellule trigger" 
		 * 
		 *	@param x int
		 *	@param y int
		 *	@param z int
		 *	@return Object
		 */
		private function addCellTrigger(x:int, y:int, z:int):Object
		{
			var tv:Object = beta.createTileView(createCCell());
			var up:Object = beta.createUPoint(x, y, z, dataMapProxy.tilew, dataMapProxy.tileh, dataMapProxy.tiled);
			var t:Object = beta.createAbstractTile(String(x + "-" + y + "-" + z), up, tv);
			isoscene.debugLayer.addTile(t);
			
			return t;
		}
		
		/**
		 *	Nettoie un trigger de ses arguments superflus d'après
		 * le formauaire en cours
		 *	@param tr Object	le trigger (TriggerProperties)
		 */
		private function cleanTrigger(tr:Object):void
		{
			if (currentAddForm)
			{
				var args:Dictionary = tr.arguments;
				var safeArgrs:Array = currentAddForm.getSarfeArguments().concat(["slid", "fireCount", "onComplete", "passArgs", "passVals"]);
				var n:int;
				var prop:String;
				var t:Boolean;
				var toRem:Array = [];
				for (var p:String  in args)
				{
					t = false;
					n = safeArgrs.length;
					while (--n > -1)
					{
						prop = safeArgrs[n];
						if (prop == p)
						{
							t = true;
							break
						}
					}
					if (!t)
						toRem.push(p)
				}
				// on nettoie
				n = toRem.length;
				while (--n > -1)
					delete args[toRem[n]];
				// test sur param slid
				if (args["slid"] == -1)
					delete args["slid"];
			}
		}
		
		/**
		 * Nettoie un trigger des arguments superflus
		 * 
		 *	@param tr Object type TriggerProperties
		 */
		private function cleanTriggerV2(tr:Object):void
		{
			var form:Object = addForms[tr.triggerClassId];
			if (!form) return;
		
			// check les paramètres saufs
			var formSafeArgrs:Array = form.getSarfeArguments();
			if (formSafeArgrs) {
				// on doit garder tous les paramètres...				
				if (formSafeArgrs[0] == "all") {
					return;
				}
			}
			
			var safeArgrs:Array = formSafeArgrs.concat(["slid", "fireCount", "onComplete", "passArgs", "passVals", "ovT"]);

			var args:Dictionary = tr.arguments;
			var n:int
			var prop:String;
			var t:Boolean;
			var toRem:Array = [];
			for (var p:String  in args)
			{
				t = false;
				n = safeArgrs.length;
				while (--n > -1)
				{
					prop = safeArgrs[n];
					if (prop == p)
					{
						t = true;
						break;
					}
				}
				if (!t) {
					toRem.push(p);
				}
			}
			// on nettoie
			n = toRem.length;

			while (--n > -1) {
				delete args[toRem[n]];
			}				
		}
		
		/**
		 *	Sélectione la source (dans la scéne) du trigger en cours d'édition
		 *	@private
		 */
		private function selectTargetOfCurrentTrigger():void
		{
			if (cliTargetTriggers.selectedItem)
			{
				if (currentTarget)
				{
					if (triggersProxy.hasTrigger(currentTarget))
						currentTarget.filters = [new GlowFilter(0xFF9900)];
					else
						currentTarget.filters = [];
				}
				var tr:Object = cliTargetTriggers.selectedItem.data;
				var targId:String = tr.refId;
				if (targId)
				{
					var targ:Object = parentApplication.isosceneHelper.getTile(targId);
					if (targ)
					{							
						targ.filters = [new GlowFilter()];
						currentTarget = targ;
					}
				}
			}
				
		}
		
		/**
		 * 	Mets à jour le formulaire ...action !
		 * 
		 *	@param triggerId int
		 *	@return Boolean
		 */
		private function updateForm(source:Object = null, autoSelect:Boolean = false, displayBrothers:Boolean = false):void
		{
			var trigger:Object;
			
			if (!source)
			{
				// si pas de source, on fait la mise à jour en fonction de l'entrée
				// selectionnée dans la liste (si selection il y à)
				var selIt:Object = cliTargetTriggers.selectedItem
				if (selIt) {
					updateForm(selIt.data, true, true);
					return;
				}
				currentTrigger = null;
				return;
			}
			
			// > on est sur un tile
			if ("ID" in source)
			{
				var tid:String = source.ID;
				if (triggersProxy.hasTrigger(source))
				{					
					trigger = triggersProxy.getAllTriggers(tid)[0];
					displayBrothers = true;
					autoSelect = true;
					// mise à jour du titre
				} else {
					// remise à "0" des combos et listes
					cliTargetTriggers.dataProvider.removeAll();
					cliChainedTriggers.dataProvider.removeAll();
					ccbTriggerFireType.selectedIndex = 0;
					ccbTriggerType.selectedIndex = 0;
					if (currentAddForm) currentAddForm.safeSave();
					clearAddForm();
					return;
				}
			}
			else // > on est sur un trigger
			{
				trigger = source;
			}
			
			// on test si le trigger existe
			if (!trigger) {
				currentTrigger = null;
				return;
			}
			
			// mise à jour affichage actif / inactif depuis scene
			/*lbFromM.enabled = trigger.activeFromMaps ? true : false;
			lbNotFM.enabled = trigger.inactiveFromMaps ? true : false;*/
			
			// on test si la source est un trigger selectionné dans la liste
			if (cliTargetTriggers.selectedItem)
			{
				if (cliTargetTriggers.selectedItem.data == trigger)
				{
					// -- mise à jour text info
					var refId:String = trigger.refId;
					var refObj:Object = parentApplication.isosceneHelper.getTile(refId);
					if (refObj)
					{
						if (refObj.ID.split("-").length == 3)
						{
							// > texte pour trigger sur céllule
							clbCurrentTarget.text = "céllule " + refId;
							dtTriggerFireTypes = dtTriggerFireTypesForCells;
						} else {
							// > texte pour trigger sur tile
//							clbCurrentTarget.text = "actions du tile " + refId + refObj.name;
							clbCurrentTarget.text =  refObj.name + " (id:" + refId + ")";
							dtTriggerFireTypes = dtTriggerFireTypesForTiles;
						}
					} else {
						// > texte pour trigger chaîné
						clbCurrentTarget.text = clbCurrentTarget.text = "action(s) chainée(s)";
						dtTriggerFireTypes = dtTriggerFireTypesForChain;
					}
				
//					clbCurrentTarget.text+= " - action id: " + trigger.id + " -";
					clbCurrentTrigger.text = "action id: " + trigger.id;
					
					// -- mise à jour du combo type de déclenchement
					var it:Object;
					var fireType:int = trigger.fireType;
					var n:int = dtTriggerFireTypes.length;
					while (--n > -1)
					{
						it = dtTriggerFireTypes[n];
						if (it.data == fireType)
						{
							ccbTriggerFireType.selectedIndex = n;
							break;
						}
					}

					// -- mise à jour du combo action (class de trigger)
					n = dtTriggerTypes.length;
					var trClassId:int = trigger.triggerClassId;
					while (--n > -1)
					{
						if (dtTriggerTypes[n].data == trClassId)
						{
							ccbTriggerType.selectedIndex = n;
							break;
						}
					}
			
					// -- mise à jour intitulé
					var item:Object = cliTargetTriggers.selectedItem;
//					var tit:String = triggersClass[n];
					var tit:String = triggersClass[dtTriggerTypes[n].data];
					if (trigger.isChained) tit = "< " + tit;
					item.title = tit;
					cliTargetTriggers.dataProvider.itemUpdated(item, "title", null, tit);

					// -- mise à jour liste enchainement
					cliChainedTriggers.dataProvider.removeAll();
					var cpList:Array = [];
					if (trigger.hasChainedTrigger)
					{
						var tpcList:Array = trigger.chainedTriggers;
						n = tpcList.length;
						var tc:Object;
						for (var i:int = 0; i < n; i++)
						{
							tc = tpcList[i];
							tit = triggersClass[tc.triggerClassId];
							if (tc.hasChainedTrigger) tit+= " >";
							cliChainedTriggers.dataProvider.addItem({ title:tit, data:tc });
						}
					}
					
					currentTrigger = trigger;
					// -- mise à jour du formulaire additionnel
					updateAddForm(trigger);
					
					// on s'arrête là
					return;
				}
			}

			// remise à "0" des combos et listes
			cliTargetTriggers.dataProvider.removeAll();
			cliChainedTriggers.dataProvider.removeAll();
			ccbTriggerFireType.selectedIndex = 0;
			ccbTriggerType.selectedIndex = 0;
			
			// suppression du formulaire additionnel
			/*if (currentAddForm)
			{
				triggerForm.removeChild(DisplayObject(currentAddForm));
				currentAddForm = null;
			}*/

			// index pour l'autoselection
			var sind:int = 0;
			
			// il faut afficher les tous triggers qui sont associés à la même
			// source qui celui-ci
			if (displayBrothers)
			{
				// on retrouve les triggers qui sont associès a la même source (celui-ci inclu)
				var brotherList:Array;
				// on mets à jour la List des triggers
				var tp:Object;
				/*if (trigger.refId != -1)
				{*/
					brotherList = triggersProxy.getAllTriggers(trigger.refId);
					n = brotherList.length;
					for (i = 0; i < n; i++)
					{
						tp = brotherList[i];
						cliTargetTriggers.dataProvider.addItem({ title:triggersClass[tp.triggerClassId], data:tp })
						if (tp == trigger)
							sind = i;
					}
				/*} else {
					alTriggers = triggersProxy.allTriggers;
					tid = trigger.id;
					n = alTriggers.length;
					var ptp:Object;
					while (--n > -1)
					{
						tp = alTriggers[n];
						if (!tp.arguments["onComplete"]) continue;
						if (!tp.arguments["onComplete"].indexOf(tid))
						{
							ptp = tp;
							break;
						}
					}
					if (tp)
					{
						brotherList = triggersProxy.getAllTriggers(tp.refId);
						trace("DISPLAY BROTHERS ", brotherList.length);						
						n = brotherList.length;
						for (i = 0; i < n; i++)
						{
							tp = brotherList[i];
							cliTargetTriggers.dataProvider.addItem({ title:triggersClass[tp.triggerClassId], triggerProp:tp })
							if (tp == trigger)
								sind = i;
						}
					}
				}*/

			} else {				
				// intitulé de la classe de trigger
				tit = triggersClass[trigger.triggerClassId];
				// test si le trigger est châiné ) un autre
				if (trigger.isChained)
					tit = "< " + tit;
				// ajout de l'entrée dans la liste
				cliTargetTriggers.dataProvider.addItem({ title:tit, data:trigger });
			}

			currentTrigger = trigger;
			
			if (autoSelect)
			{
				cliTargetTriggers.selectedIndex = sind;
				updateForm(trigger);
			}
		}
		
		
		private function updateComForm (tprop:Object) : void
		{
			
		}
		
		/**
		 * Mise à jour du formulaire additionnel
		 * 
		 *	@param tprop Object TriggerProperties
		 */
		private function updateAddForm(tprop:Object):void
		{
			var cid:int = tprop.triggerClassId;
			if (cid < 1) {
				clearAddForm();
				return;
			}
			
			// > Formulaire propprétés spécifiques
			var nform:Object = addForms[cid];
			if (nform != currentAddForm)
			{
				if (currentAddForm) currentAddForm.safeSave();

				clearAddForm();
				if (nform)
				{
					currentAddForm = nform;
					currentAddForm.trigger = tprop;
					triggerForm.addChild(DisplayObject(currentAddForm));
				}
			} else {
				// le type d'action est le même que celui du nouveau trigger en édition
				// donc le formulaire est déjà le bon
				if (currentAddForm.trigger != tprop)
				{
					currentAddForm.safeSave();
					currentAddForm.trigger = tprop;
				}
			}
			
			// > Formulaire propprétés communes
//			- 0|17|target|12/25/0
			// recup des actions modifiées par ce trigger
			/*var ovT:Object = tprop.arguments["ovT"];
						if (ovT != null)
						{
							var en:Array;
							var ct:Object;
							for each (var m:Object in ovT)
							{
								en = m.split("|");
								ct = triggersProxy.getTrigger(en[1]);
								if (ct) {
									dpOverrideTriggers.addItem({title:triggersClass[ct.triggerClassId],
																exec:en[0] > 0 ? en[0] : "",
																data:ct});
								}
							}
						}*/
		}
		
		/**
		 * Mise à 0 du formulaire
		 * 
		 *	@private
		 */
		private function clearForm () : void
		{			
			// on enleve le formulaire additionnel en cours
			if (currentAddForm)
			{
				// on previens le formulaire additionnel en cours du changement de type d'action
				currentAddForm.safeSave();
				triggerForm.removeChild(DisplayObject(currentAddForm));
				currentAddForm = null;
			}
			// remise à "0" des combos et listes
			clbCurrentTarget.text = "";
			clbCurrentTrigger.text = "";
			cliTargetTriggers.dataProvider.removeAll();
			cliChainedTriggers.dataProvider.removeAll();
			ccbTriggerFireType.selectedIndex = 0;
			ccbTriggerType.selectedIndex = 0;
			dtTriggerFireTypes = null;
			/*lbFromM.enabled = false;
			lbNotFM.enabled = false;*/
			currentTrigger = null;
		}
		
		/**
		 * Mise à 0 du formulaire additionnel
		 * 
		 *	@private
		 */
		private function clearAddForm () : void
		{
			// on enleve le formulaire additionnel en cours
			if (currentAddForm)
			{
				triggerForm.removeChild(DisplayObject(currentAddForm));
				currentAddForm = null;
			}
			// upadte formulaire options communes
			/*dpOverrideTriggers.removeAll();*/
		}
//public var dgAllTriggersList:Object = {};		
	    ]]>
	</mx:Script>
	
	<mx:states>
		<!-- popup liste de tous les triggers de la scène en cours -->
		<!-- <mx:State name="onRemoved">
			
		</mx:State> -->
		<mx:State name="onAdd">
			<mx:AddChild relativeTo="{parentApplication.optionBox}">
				<mx:HBox id="testm" width="100%">
					<mx:DataGrid id="dgAllTriggersList" width="100%"
									dataProvider="{dpAllTriggers}" dragEnabled="true">
				        <mx:columns>
							<mx:DataGridColumn width="50" dataField="id" headerText="id" />
				            <mx:DataGridColumn dataField="title" headerText="action" />
				            <mx:DataGridColumn dataField="source" headerText="source" />
							<mx:DataGridColumn dataField="firetype" headerText="déclencheur" />
							<mx:DataGridColumn dataField="chained" headerText="chainage" />
							<mx:DataGridColumn dataField="chainedTo" headerText="chainé à" />
				        </mx:columns>
				    </mx:DataGrid>
				<!-- </mx:AddChild> -->
				<!-- <mx:AddChild relativeTo="{parentApplication.libBox}"> -->
				    <mx:ButtonBar id="buttonBarAllTriggersList" itemClick="buttonBarsHandler(event);"
								buttonHeight="20" buttonWidth="20" horizontalAlign="center"
								direction="vertical" horizontalGap="0" verticalAlign="middle" verticalGap="0"
								focusEnabled="false" dataProvider="{dpBtnEARAllTList}" />
				</mx:HBox>
			</mx:AddChild>
			<mx:SetProperty target="{dgAllTriggersList}" name="height" value="{parentApplication.optionBox.height}" />
		</mx:State>
	</mx:states>
	
	<mx:HBox width="100%">
		<mx:Label width="70%" text="selectionez une cible dans la scène" id="clbCurrentTarget" />
	</mx:HBox>
	<mx:HBox width="100%">
		<mx:VBox width="50%">
			<!-- boutons ajouter / supprimer / parent trigger -->
			<mx:HBox>
			<mx:ButtonBar id="buttonBarARB"
				direction="horizontal" buttonHeight="20" buttonWidth="20"
				horizontalAlign="center" verticalAlign="middle"				
				horizontalGap="6" verticalGap="0" focusEnabled="false"
				dataProvider="{dpBtnARB}" itemClick="buttonBarsHandler(event);"/>
			<mx:Label text="" id="clbCurrentTrigger" />
			</mx:HBox>
			<!-- liste des triggers en édition -->
			<mx:List id="cliTargetTriggers" width="100%" dataTipField="data" dataProvider="{dtTargetTriggers}"
				labelField="title" change="cliTargetTriggersHandler(event);" />
		</mx:VBox>
		<mx:VBox width="50%">
			<mx:Label text="type d'action / déclencheur" />
			<flmp:DisabledComboBox id="ccbTriggerType"
						width="100%" rowCount="100"
						dataProvider="{dtTriggerTypes}"
						close="ccbTriggerTypeHandler(event);" />
			<flmp:DisabledComboBox id="ccbTriggerFireType" dataProvider="{dtTriggerFireTypes}"
								width="100%" rowCount="100"
					            close="ccbTriggerTypeHandler(event);" />
					
			<mx:Label text="actions enchaînées :" id="tx_complete" />
			<mx:HBox>
				<!-- liste des triggers chaînés -->
				<mx:List id="cliChainedTriggers" width="100%" height="76" dataProvider="{dtChainedTriggers}"
							dataTipField="data" labelField="title" dragEnabled="true" dropEnabled="true" dragMoveEnabled="true" />
				<!-- bar de boutons editer / ajouter / supprimer triggers chaînés -->
			    <mx:ButtonBar id="buttonBarEAR" itemClick="buttonBarsHandler(event)"
							buttonHeight="20" buttonWidth="20" horizontalAlign="center"
							direction="vertical" horizontalGap="0" verticalAlign="middle" verticalGap="0"
							focusEnabled="false" dataProvider="{dpBtnEAR}" />
			</mx:HBox>
		</mx:VBox>
	</mx:HBox>
	
	<mx:TabNavigator id="tn_triggerOpts" width="100%" height="100%" paddingLeft="10" paddingTop="10" paddingRight="10" paddingBottom="10"  backgroundColor="#F7F7F7">
		<!-- 
			Onglet conteneur formaulaire additionnel
		-->
		<mx:VBox id="triggerForm" label="options spécifiques"
				width="100%" height="100%" />
		<!-- 
			Onglet Options communes
		-->
		<mx:Box width="100%" label="options génériques">
			<flmp:TriggerForm0 trigger="{currentTrigger}" />
			<!-- <mx:HBox> -->
			<!-- actif depuis scène(s) -->
			<!-- <mx:Label id="lbFromM" text="actif depuis" enabled="false" />
						<mx:Button id="btFromM" toolTip="activer l'action seulement si le joueur provient de certaine(s) scène(s)"
							icon="@Embed('icons/page_white_edit.png')" width="20"
							toggle="true" enabled="{!btNotFM.selected}"
							click="btnEditFromNotFromMHandler(event)" /> -->
			<!-- inactif depuis scène(s) -->
			<!-- <mx:Label id="lbNotFM" text="inactif depuis" enabled="false" />
						<mx:Button id="btNotFM" toolTip="désactiver l'action si le joueur provient de certaine(s) scène(s)"
							icon="@Embed('icons/page_white_edit.png')" width="20"
							toggle="true" enabled="{!btFromM.selected}"
							click="btnEditFromNotFromMHandler(event)" /> -->
			<!-- Nombre d'exections -->
			<!-- <mx:Label text="nbr exec" />
			<mx:TextInput id="ti_maxFireCount" toolTip="Nombre d'executions maximum (laisser vide pour indéfiniment)"
							restrict="0-9" width="25"
							text="{currentTrigger.maxFireCount != int.MAX_VALUE ? currentTrigger.maxFireCount : ''}"
							change="onChangeCommonTriggerProp(event);" />
			</mx:HBox> -->
			<!-- Ecrasement propriétées de triggers -->
			<!-- <mx:HBox visible="false" width="100%">
						<mx:Label text="Modifier d'autres actions :"/>
						<mx:Box width="100%" horizontalAlign="right">
							<mx:ButtonBar id="buttonBar"
								direction="horizontal" buttonHeight="20" buttonWidth="20"
								horizontalAlign="center" verticalAlign="middle"				
								horizontalGap="6" verticalGap="0" focusEnabled="false" />
						</mx:Box>
					</mx:HBox>
				    <mx:DataGrid visible="false" id="cliOverrideTrigger" width="100%" rowCount="3" editable="true"
						dragEnabled="true" dropEnabled="true" dragMoveEnabled="true"
						dataProvider="{dpOverrideTriggers}">
				        <mx:columns>
				            <mx:DataGridColumn dataField="title" headerText="action" editable="false" />
				            <mx:DataGridColumn width="90" dataField="exec" headerText="à l'éxecution" />
				        </mx:columns>
				    </mx:DataGrid> -->
		</mx:Box>
	</mx:TabNavigator>
</mx:Box>
